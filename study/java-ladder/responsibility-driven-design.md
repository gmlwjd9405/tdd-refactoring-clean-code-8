# 책임 주도 설계
> [오브젝트 책](http://www.yes24.com/Product/Goods/74219491)의 3장을 참고해 작성했다.

## 객체지향 설계 및 구현
### 객체지향 패러다임 관점에서 핵심은?
- 역할(role), 책임(responsibility), 협력(collaboration)
- 객체지향 설계의 핵심은 **협력**을 구성하기 위해 적절한 객체를 찾고 적절한 **책임**을 할당하는 과정에서 드러난다.

### 객체지향 설계 및 구현 접근 방식은?
#### Bottom Up 구현 및 설계
- 정의
  - 구현에 초점을 맞춰 일단 구현한 후 지속적인 리팩토링 통해 객체의 역할, 책임, 협력을 찾아나가면서 설계를 개선해 나가는 접근 방식.
- 구현 및 설계
  - **일단 구현** 후 지속적인 리팩토링
  - 객체 설계를 어떻게 해야할지 모르겠다면 시작은 클래스 메소드 구현으로 시작한 후 지속적인 리팩토링
  - 리팩토링할 때는 객체지향 생활체조 원칙, 클린코드 원칙을 참고해 리팩토링
- 예시
  ```java
  public class Car {
    private static final int FORWARD_NUM = 4;
    private static final int MAX_BOUND = 10;

    private String name;
    private int position = 0;
    ...

    public void move() {
      if (getRandomNo() >= FORWARD_NUM)
        this.position++;
    }

    private int getRandomNo() {
      Random random = new Random();
      return random.nextInt(MAX_BOUND);
    }
  }
  ```
  ```java
  public class Car {
    private static final int FORWARD_NUM = 4;
    private static final int MAX_BOUND = 10;

    private Name name; // 원시값 포장
    private Position position = 0;
    ...
    public void move(RandomNo randomNo) {
      if (randomNo.canMove())
        this.position = this.position.move();
    }
  }
  ```

#### Top Down 설계 및 구현
- 정의
  - 책임에 초점을 맞춰 전체적인 설계의 방향과 흐름을 결정한 후 구현을 시작하는 접근 방식.
  - **책임 주도 설계(Responsibility-Driven Design)**라고 부른다.

## 책임
### 책임이란 무엇인가?
- 책임이란 객체에 의해 정의되는 응집도 있는 행위의 집합으로,
- **객체가 유지해야 하는 정보와 수행할 수 있는 행동**에 대해 개략적으로 서술한 문장이다.
- 즉, 객체가 '무엇을 알고 있는가'와 '무엇을 할 수 있는가' 로 구성된다.

#### 하는 것
- 객체를 생성하거나 계산을 수행하는 등의 스스로 하는 것
- 다른 객체의 행동을 시작시키는 것
- 다른 객체의 활동을 제어하고 조절하는 것

#### 아는 것
- 사적인 정보에 관해 아는 것
- 관련된 객체에 대해 아는 것
- 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것

### 책임 주도 설계란?
- 프로그래밍의 책임을 찾고 책임을 수행할 적절한 객체를 찾아 책임을 할당하는 방식으로 협력을 설계하는 방법
- 책임을 먼저 찾고 클래스를 설계한다.

### 책임 주도 설계 과정
- 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다.
- 시스템 책임을 더 작은 책임으로 분할한다.
- 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.
- 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다.
- 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다.

### 책임 주도 설계의 의미 
- 책임 주도 설계는 자연스럽게 객체의 구현이 아닌 **책임에 집중**할 수 있게 한다.
- 구현이 아닌 책임에 집중하는 것이 중요한 이유는 **유연하고 견고한 객체지향 시스템**을 위해 가장 중요한 재료가 바로 책임이기 때문이다.

### 예시 (책임 주도 설계로 자동차 경주게임 구현)
1. 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다.
    - 책임을 파악한 후 책임을 할당할 객체를 바로 결정하지 않아도 된다.
2. 시스템 책임을 더 작은 책임으로 분할한다.
    1) 시스템 책임을 더 작은 책임으로 분할한다.
      - []()
    2) 시스템 책임을 더 작은 책임으로 분할한다.
      - []()
3. 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.
    1) 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.
      - []()
    2) 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.
      - []()
4. 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾고, 협력하게 한다.
    - []()


## 역할
- 프로그래밍의 책임을 찾고 책임을 수행할 적절한 객체를 찾아 책임을 할당하고, 객체가 협력하도록 설계하는 것만으로도 충분할 수 있다.
- But, 유연하고 재사용 가능한 협력을 얻으려면 역할 이라는 개념을 고려해 설계해야 한다.

### 역할이란?
- 객체가 어떤 특정한 협력 안에서 수행하는 책임의 집합을 역할이라고 부른다.
- 역할은 다른 것으로 교체할 수 있는 책임의 집합이다.

### 역할이 이해되지 않는다면...
- 더블 캐스팅 - 배우와 배역의 관계로 이해해본다.
- 더블 캐스팅은 연극, 뮤지컬에서 두 사람에게 동시에 한 배역을 맡김
- 연극은 협력, 배역은 역할, 배우는 객체
  - **배우와 배역의 관계**
    - 서로 다른 배우들이 동일한 배역을 연기할 수 있다.
    - 한 배우가 다양한 연극 안에서 서로 다른 배역을 연기할 수 있다.
  - **객체와 역할의 관계**
    - 서로 다른 객체들이 동일한 역할을 수행할 수 있다.
    - 한 객체가 다양한 협력 안에서 서로 다른 역할을 수행할 수 있다.

### 협력이라는 문맥 안에서 역할
- 협력이라는 문맥 안에서 역할은 특정한 협력에 참여해서 책임을 수행하는 객체의 일부다.
- 일반적으로 역할은 객체가 협력에 참여하는 잠시 동안에만 존재하는 일시적인 개념이다.

### 자동차 경주 게임에서 역할 찾기
- 이동 가능여부 결정하는 역할
  - Random 값에 따라 이동 여부 결정
  - 특정 시간에 따라 이동 여부 결정
  - []()
- 역할에 이름을 부여
  - []()
  - 역할을 프로그래밍 언어로 표현하는 수단이 **인터페이스(interface)** 이다.

### 객체들이 어떻게 협력할 것인가?
- 객체, 책임, 역할을 찾았다면 다음 단계는 객체들이 어떻게 협력할 것인가(의존성)를 결정해야 한다.
- 의존성(의존관계, dependency)을 어떻게 관리하느냐에 따라 유연한 설계 여부가 달라질 수 있다.

#### 컴파일타임 의존성
```java
public class Car {
  public void move() {
    MovingStrategy movingStrategy = new RandomValueMovingStrategy();
    if (movingStrategy.movable()) {
      this.position = position.move();
    }
  }
}
```
- 단점
  - 변경 발생 시 제약 사항이 생긴다. 
  - 테스트 하기 어렵다.
  
#### 런타임 의존성
```java
public class Car {
  public void move(MovingStrategy movingStrategy) {
    if (movingStrategy.movable()) {
      this.position = position.move();
    }
  }
}
```
- 장점
  - 테스트가 쉽다.
  - 인터페이스에 대한 다른 구현체로 쉽게 변경이 가능하므로 유연성이 높아진다.
  - 의존 관계를 외부에서 주입한다. (DI)

- 유연한 설계를 지향한다면 컴파일타임 의존성을 런타임 의존성으로 대체한다.
- 런타임 의존성으로 대체하다보면 테스트하기 쉬운 설계가 가능해진다.
- 테스트하기 쉬운 설계를 지향하다보면 유연한 설계가 가능해지는 경험을 종종 할 수 있다.


## 책임 주도 설계가 진정한 대안인가?
- 책임 주도 설계에 익숙해지기 위해서는 부단한 노력과 시간이 필요하다.
- 책임 관점에서 사고하기 위해서는 충분한 경험과 학습이 필요하다.
- **어떻게 하면 좋을까?**
  - 최대한 빠르게 기능 구현 -> 지속적인 리팩토링
  - TDD 사이클을 반복해 설계의 품질을 높혀 나간다.
  - 리팩토링을 할 때 '객체지향 설계 체조 원칙', '클린코드 설계 원칙'을 지키면서...
- **Bottom Up 방식 선호**
  - 시작 단계에서 완벽한 설계를 하겠다는 욕심을 버려라.
  - 현장의 요구사항은 끊임없이 변화한다.
  - 점진적으로 설계를 개선하는 연습을 하는 것이 현장형(야생) 설계 연습이다.
  - 다양한 방식으로 연습하는 것이 좋다.


---

### :triangular_ruler: [Ladder Home](https://github.com/gmlwjd9405/tdd-refactoring-clean-code-8/tree/master/study/java-ladder)
